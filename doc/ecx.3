.\" Text automatically generated by txt2man
.TH ecx 1 "17 January 2026" "0.1.0dev0+fb2fe0a" "User commands"
.SH NAME
\fBecx \fP- library for electrochemistry
\fB
.SH LIBRARY
ecx (\fB-libecx\fP, \fB-lecx\fP)
.SH SYNOPSIS
.nf
.fam C
  ecx (Fortran): use ecx
  ecx (C): include "ecx.h"
  ecx (python): import pyecx

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION
ecx a Fortran library for providing a collection of routines for electrochemistry.
A C API allows usage from C, or can be used as a basis for other wrappers.
A Python wrapper allows easy usage from Python.
.PP
It covers:
.RS
.TP
.B
o kinetics
Nernst, Butler-Volmer
.TP
.B
o electrochemical
Impedance, Admittance, Circuit Elements, Equivalent Circuits
.TP
.B
o photoelectrochemistry
Photocurrent, Band-gap, space charge.
.RE
.PP
The C API is defined by adding a prefix to the functions from the Fortran
API due to the lack of module/namespace feature in the C language.
The functions are therefore following this template:
(c_prefix)fortran_func.
.PP
Fortran API
.RS
.TP
.B
o function \fBget_version\fP()result(fptr)
Get the version.
.RS
.TP
.B
o \fBcharacter\fP(len=:), pointer :: fptr
Version of the library.
.RE
.TP
.B
o pure elemental function \fBkTe\fP(T)result(r)
Compute the thermal voltage.
.RS
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: T
Temperature in 째C.
.TP
.B
o \fBreal\fP(dp) :: r
Thermal voltage in V.
.RE
.TP
.B
o subroutine \fBz\fP(p, w, zout, e, errstat, errmsg)
Compute the complex impedance.
.RS
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: \fBp\fP(:)
Parameters defining the element e
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: \fBw\fP(:)
Angular frequencies in rad.s-1
.TP
.B
o \fBcharacter\fP(len=1), \fBintent\fP(in) :: e
Electrochemical element: R, C, L, Q, O, T, G
.TP
.B
o \fBcomplex\fP(dp), \fBintent\fP(out) :: \fBzout\fP(:)
Complex impedance in Ohms.
.TP
.B
o \fBinteger\fP(int32), \fBintent\fP(out) :: errstat
Error status
.TP
.B
o \fBcharacter\fP(len=:), \fBintent\fP(out), pointer :: errmsg
Error message
.RE
.TP
.B
o subroutine \fBmm\fP(p, w, zout, n)
Compute the measurement model.
.RS
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: \fBp\fP(:)
Parameters.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: \fBw\fP(:)
Angular frequencies in rad.s-1
.TP
.B
o \fBcomplex\fP(dp), \fBintent\fP(out) :: \fBzout\fP(:)
Complex impedance in Ohms.
.TP
.B
o \fBinteger\fP(int32), \fBintent\fP(in) :: n
Number of voigt elements.
.RE
.TP
.B
o pure function \fBnernst\fP(E0, z, aox, vox, ared, vred, \fBT)result\fP(E)
Compute the Nernst electrochemical potential in V.
.RS
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: E0
Standard electrochemical potential in V.
.TP
.B
o \fBinteger\fP(int32), \fBintent\fP(in) :: z
Number of exchanged electrons.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: \fBaox\fP(:)
Activities of the oxidants.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: \fBvox\fP(:)
Coefficients for the oxidants.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: \fBared\fP(:)
Activities of the reductants
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: \fBvred\fP(:)
Coefficients for the reductants.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: T
Temperature in 째C.
.TP
.B
o \fBreal\fP(dp) :: E
Nernst potential in V.
.RE
.TP
.B
o pure elemental function \fBsbv\fP(U, OCV, j0, aa, ac, za, zc, A, \fBT)result\fP(I)
Compute Butler Volmer equation without mass transport.
.RS
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: OCV
Open Circuit Voltage in V.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: U
Electrochemical potential in V.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: j0
Exchange current density in A.cm-2.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: aa
Anodic transfer coefficient.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: ac
Cathodic transfer coefficient.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: za
Number of exchnaged electrons in the anodic branch.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: zc
Number of exchnaged electrons in the cathodic branch.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: A
Area in cm2.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: T
Temperature in 째C.
.TP
.B
o \fBreal\fP(dp) :: I
Current in A.
.RE
.TP
.B
o pure elemental function \fBbv\fP(U, OCV, j0, jdla, jdlc, aa, ac, za, zc, A, \fBT)result\fP(I)
Compute Butler Volmer equation with mass transport.
.RS
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: OCV
Open Circuit Voltage in V.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: U
Electrochemical potential in V.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: j0
Exchange current density in A.cm-2.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: jdla
Anodic diffusion limiting current density in A.cm-2.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: jdlc
Cathodic diffusion limiting current density in A.cm-2.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: aa
Anodic transfer coefficient.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: ac
Cathodic transfer coefficient.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: za
Number of exchnaged electrons in the anodic branch.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: zc
Number of exchnaged electrons in the cathodic branch.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: A
Area in cm2.
.TP
.B
o \fBreal\fP(dp), \fBintent\fP(in) :: T
Temperature in 째C.
.TP
.B
o \fBreal\fP(dp) :: I
Current in A.
.RE
.RE
.PP
C API
.RS
.IP \(bu 3
char* \fBecx_get_version\fP(void)
.IP \(bu 3
const double ecx_core_PI
.IP \(bu 3
const double ecx_core_T_K
.IP \(bu 3
void \fBecx_core_nm2eV\fP(double *lambda, double *E, size_t n)
.IP \(bu 3
void \fBecx_core_kTe\fP(double *T, double *kTE, size_t n)
.IP \(bu 3
double \fBecx_kinetics_nernst\fP(double E0, int z, double *aox, double *vox, size_t nox, double *ared, double *vred, size_t nred, double T)
.IP \(bu 3
void \fBecx_kinetics_sbv\fP(double *U, double OCV, double j0, double aa, double ac, double za, double zc, double A, double T, double *i, size_t n)
.IP \(bu 3
void \fBecx_kinetics_bv\fP(double *U, double OCV, double j0, double jdla, double jdlc, double aa, double ac, double za, double zc, double A, double T, double *i, size_t n)
.IP \(bu 3
void \fBecx_eis_z\fP(double *p, double *w, ecx_cdouble *z, char e, size_t k, size_t n, int *errstat, char *(*errmsg))
.RE
.PP
Python wrappers
.RS
.IP \(bu 3
\fBz\fP(e:str, w:Union[np.ndarray,array.array,int,float], p:Union[np.ndarray,array.array])->np.ndarray
.SH NOTES
To use ecx within your fpm <https://github.com/fortran-lang/fpm>
project, add the following lines to your file:
.PP
.nf
.fam C
        [dependencies]
        ecx = { git="https://github.com/MilanSkocic/ecx.git" }

.fam T
.fi
.SH EXAMPLE
Example in Fortran:
.PP
.nf
.fam C
        program example_in_f
            use iso_fortran_env
            use ecx
            implicit none

            real(real64) :: w(3) = [1.0d0, 1.0d0, 100.0d0]
            real(real64) :: r = 100.0d0
            real(real64) :: p(3) = 0.0d0
            character(len=1) :: e
            integer :: errstat
            complex(real64) :: zout(3)
            character(len=:), pointer :: errmsg

            p(1) = r
            e = "R"
            call z(p, w, zout, e, errstat, errmsg)
            print *, zout
            print *, errstat, errmsg
        end program

.fam T
.fi
Example in C:
.PP
.nf
.fam C
        int main(void){
            int errstat, i;
            double w[3] = {1.0, 1.0, 1.0};
            double p[3] = {100.00, 0.0, 0.0};
            ecx_cdouble z[3] = {ecx_cbuild(0.0,0.0),
                                ecx_cbuild(0.0, 0.0),
                                ecx_cbuild(0.0, 0.0)};
            char *errmsg;

            ecx_eis_z(p, w, z, 'R', 3, 3, &errstat, &errmsg);

            for(i=0; i<3;i++){
                printf("%f %f \n", creal(z[i]), cimag(z[i]));
            }
            printf("%d %s\n", errstat, errmsg);
            return EXIT_SUCCESS;
        }

.fam T
.fi
Example in Python:
.PP
.nf
.fam C
        import numpy as np
        import pyecx
        import matplotlib.pyplot as plt

        R = 100
        C = 1e-6
        w = np.logspace(6, -3, 100)

        p = np.asarray([R, 0.0, 0.0])
        zr = np.asarray(pyecx.z("R", w, p))
        p = np.asarray([C, 0.0, 0.0])
        zc = np.asarray(pyecx.z("C", w, p))
        zrc = zr*zc / (zr+zc)
        print("finish")

        fig = plt.figure()
        ax = fig.add_subplot(111)

        ax.set_aspect("equal")
        ax.plot(zrc.real, zrc.imag, "g.", label="R/C")

        ax.invert_yaxis()

        plt.show()

.fam T
.fi
.SH SEE ALSO
\fBcomplex\fP(7), \fBgsl\fP(3), \fBcatanh\fP(3), \fBgnuplot\fP(1),
\fBecx_get_version\fP(3)
